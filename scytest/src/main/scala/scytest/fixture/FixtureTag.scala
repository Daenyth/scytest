package scytest.fixture

import cats.kernel.Hash
import scytest.util.TypeAnd

sealed abstract class FixtureTag private[fixture] (
    val name: String,
    val scope: FixtureScope
) {

  /** The type of resource described by this tag */
  type R

  /** Convenience function to remove evidence of `R` */
  val erase: FixtureTag = this

  override val toString: String = s"<Fixture $scope / '$name'>"

  // autogenerated
  private def canEqual(other: Any): Boolean = other.isInstanceOf[FixtureTag]

  // autogenerated
  override def equals(other: Any): Boolean = other match {
    case that: FixtureTag =>
      (that canEqual this) &&
        name == that.name &&
        scope == that.scope
    case _ => false
  }

  // autogenerated
  override def hashCode(): Int = {
    val state = Seq(name, scope)
    state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
  }
}

object FixtureTag {
  type Aux[R0] = FixtureTag { type R = R0 }

  def apply[R0](name: String, scope: FixtureScope): FixtureTag.Aux[R0] =
    new FixtureTag(name, scope) {
      type R = R0
    }

  private val hashInstance = Hash.fromUniversalHashCode[FixtureTag]
  implicit def fixtureTagInstance[T <: FixtureTag]: Hash[T] =
    hashInstance.asInstanceOf[Hash[T]]

}

object FTList extends TypeAnd[FixtureTag.Aux]
